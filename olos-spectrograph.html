<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-input/iron-input.html">
<!--
A spectrograph plots the frequency spectrum over time. The Y axis is frequencies
from lowest (20Hz) to highest (22050Hz). X axis is time. Colors represent amplitude at the given frequency.

Play with `speed`, `smoothing` and `bincount`

##### Example


@element olos-spectrograph
@blurb 
@status alpha
@homepage http://olosmusic.github.io/olos-spectrograph
-->
<dom-module id="olos-spectrograph">
  <link rel="import" type="css" href="olos-spectrograph.css">
  <template>

    <div class="controls">
    </div>

    <div id="canvas_container">
    </div>

  </template>
  <script type="text/javascript">
    (function (params) {
      Polymer({
        is: 'olos-spectrograph',
        properties: {
          // p5 sketch
          _sketch: { value: null },
          ampMode: {
            type: String,
            value: 'log',
            notify: true
          },
          /**
           *  Web Audio API analyserNode
           *  
           *  @property analyserNode
           */
          analyserNode: { value: null },
          /**
           *  Number of bins the FFT will return as it divides the frequency spectrum.
           *  Between 16 and 2048.
           *  
           *  @property binCount
           *  @type Number
           *  @default 256
           */
          binCount: {
            type: Number,
            value: 256,
            notify: true
          },
          freqMax: {
            value: function () {
              return audioContext.sampleRate / 2;
            },
            notify: true
          },
          // TO DO: implement these to allow zoom
          freqMin: {
            type: Number,
            value: 20,
            notify: true
          },
          /**
           *  Scaling of the frequency spectrum (Y axis). 
           *  Can be "lin" (linear), or "log" (logarithmic).
           *  Logarithmic gives more weight to the lower part
           *  of the frequency spectrum, which more closely
           *  resembles how we perceive pitch, while linear emphasizes
           *  harmonic relationships.
           *  
           *  @property freqMode
           *  @type String
           *  @default 'log'
           */
          freqMode: {
            type: String,
            value: 'lin',
            notify: true
          },
          // inputs and outputs
          inputAudio: {
            value: null,
            notify: true
          },
          output: {
            value: null,
            notify: true
          },
          publicMethods: {
            type: Array,
            value: function () {
              return [
                'setup',
                'drawLoop'
              ];
            }
          },
          rootfolder: {
            type: String,
            value: '../olos-spectrograph/'
          },
          /**
           *  Rate of smoothing for the frequency spectrum amplitude analysis.
           *  Between 0 and 1.
           *  
           *  @property smoothing
           *  @type Number
           *  @default 0.8
           */
          smoothing: {
            type: Number,
            value: 0.8,
            notify: true
          },
          /**
          *  Speed that the spectograph passes by, in pixels per draw loop.
          *  The draw loop is ~15 frames per second.
          *  
          *  @property speed
          *  @type Number
          *  @default 2
          */
          speed: {
            type: Number,
            value: 2
          }
        },
        ready: function () {
          var self = this;
          self._audioContext = audioContext;
          self.playing = false;
          self.inputAudio = self.analyserNode = self.output = audioContext.createAnalyser();
          Object.defineProperty(self, 'smoothing', {
            'get': function () {
              return self.analyserNode.smoothingTimeConstant;
            },
            'set': function (val) {
              self.analyserNode.smoothingTimeConstant = val;
            }
          });
          Object.defineProperty(self, 'binCount', {
            'get': function () {
              return self.analyserNode.fftSize / 2;
            },
            'set': function (val) {
              self.analyserNode.fftSize = val * 2;
            }
          });
        },
        attached: function() {
          this._initCanvas();
        },
        setup: function () {
          // freqMode can be 'lin' or 'log'
          this.freqMode = 'lin';
          this.smoothing = 0.8;
          this.binCount = 256;
        },
        // TO DO: animate!
        _draw: function () {
          this._p5.draw();
        },
        dispose: function() {
          var self = this;
          var nodes = ['output', 'inputAudio', 'analyserNode'];
          for (var i = 0; i < nodes.length; i++) {
            try {
              var node = self[nodes[i]];
              node.disconnect();
              node = null;
            } catch(e) { }
          }
        },
        _initCanvas: function () {
          var self = this;
          self._sketch = function (sketch) {
            sketch.setup = function () {
              sketch.cnv = sketch.createCanvas(255, 255);
              sketch.background(0, 0, 0);
              sketch.colorMode(sketch.HSB, 255);
              sketch.noLoop();
              sketch.noStroke();
              sketch.pixelDensity = 2;
            };
            sketch.draw = function () {
              var freqMode = self.freqMode;
              var speed = self.speed;
              var freq = new Uint8Array(self.binCount);
              self.analyserNode.getByteFrequencyData(freq);
              sketch.copy(sketch.cnv, 0, 0, sketch.width, sketch.height, -speed, 0, sketch.width, sketch.height);
              // iterate thru current freq spectrum
              for (var i = 0; i < freq.length; i++) {
                var value;
                if (freqMode === 'log') {
                  logIndex = self.logScale(i, freq.length);
                  value = freq[logIndex];
                } else {
                  value = freq[i];
                }
                var c = value;
                sketch.fill(c, 255, c);
                var percent = i / freq.length;
                var y = percent * sketch.height;
                sketch.rect(sketch.width - speed, sketch.height - y, speed, sketch.height / freq.length);
              }
            };
            sketch.onresize = function () {
              var compStyle = getComputedStyle(self);
              var w = Math.round( Number(compStyle.width.split('px')[0]) );
              var h = Math.round( Number(compStyle.height.split('px')[0]) );
              sketch.copy(sketch.cnv, 0, 0, sketch.width, sketch.height, 0, 0, w, h);
              sketch.resizeCanvas(w, h);
              sketch.pixelDensity = 2;
            };
          };
          self._p5 = new p5(self._sketch, self.$.canvas_container);
          self._p5.canvas.style.visibility = 'visible';
        },
        drawLoop: function () {
        },
        // TO DO
        resize: function () {
          this._p5.onresize();
        },
        ///////// helper functions via
        /// https://github.com/borismus/spectrograph/blob/master/g-spectrograph.js MIT license
        /**
         * Given an index and the total number of entries, return the
         * log-scaled value.
         */
        logScale: function (index, total, opt_base) {
          var base = opt_base || 2;
          var logmax = this.logBase(total + 1, base);
          var exp = logmax * index / total;
          return Math.round(Math.pow(base, exp) - 1);
        },
        logBase: function (val, base) {
          return Math.log(val) / Math.log(base);
        }
      });
    }());
  </script>
</dom-module>
